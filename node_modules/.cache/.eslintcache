[{"/home/johndoe/Documents/GT/HackGT/DisHackGT8/Discere-Hack-GT-8/HackGT8-2/HackGT8/src/index.js":"1","/home/johndoe/Documents/GT/HackGT/DisHackGT8/Discere-Hack-GT-8/HackGT8-2/HackGT8/src/GameLogic.js":"2","/home/johndoe/Documents/GT/HackGT/DisHackGT8/Discere-Hack-GT-8/HackGT8-2/HackGT8/src/WaterLogic.js":"3"},{"size":4113,"mtime":1635030155535,"results":"4","hashOfConfig":"5"},{"size":10021,"mtime":1635027314327,"results":"6","hashOfConfig":"5"},{"size":1401,"mtime":1635027314327,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"mhtrt6",{"filePath":"10","messages":"11","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"12","usedDeprecatedRules":"13"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"13"},"/home/johndoe/Documents/GT/HackGT/DisHackGT8/Discere-Hack-GT-8/HackGT8-2/HackGT8/src/index.js",[],"/home/johndoe/Documents/GT/HackGT/DisHackGT8/Discere-Hack-GT-8/HackGT8-2/HackGT8/src/GameLogic.js",["16"],"/**Types of blocks: \"air\"; \"stone\"; \"water\"; \"fixw\"; \"buck\"; \"obsi\"\n * 0 Air\n * 1 Stone\n * 2 Water\n * 3 Fixed water\n */\n\n/** Function takes in grid, coordinates and type of block to be placed\n * returns boolean representing success / failure\n */\nimport Block from './WaterLogic.js';\n\nclass GameGrid {\n\n    constructor(size) {\n        this.size = size;\n        this.grid = this.intializeGrid(size);\n        this.bucketGrid = null;\n        this.numToIcon = {\"air\":\" \", \"stone\":\"#\", \"water\":\"o\", \"fixw\":\"o\"};\n        this.notupdated = false;\n    }\n\n    getSize() {\n        return this.size;\n    }\n\n    placeBlock(x, y, type) {\n       if (this.grid[y][x].blockType === \"air\") {\n            this.grid[y][x] = new Block(type);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /** Function takes in grid and replaces water blocks with air blocks\n     */\n    resetGrid() {\n        for (let x = 0; x <  this.grid.length; x++) {\n            for (let y = 0; y <  this.grid.length; y++) {\n                if ( this.grid[y][x].blockType === \"water\" || this.grid[y][x].blockType === \"fixw\") {\n                     this.grid[y][x] = new Block(\"air\");\n                }\n            }\n        }\n    }\n\n    intializeGrid() {\n        var grid = new Array(this.size);\n        for (var i = 0; i < this.size; i++) {\n            grid[i] = new Array(this.size);\n            for(var j=0; j<this.size; j++) {\n                grid[i][j] = new Block(\"air\");\n            }\n        }\n        return grid;\n    }\n\n    /** Function initializes bucket grid, taking in as input size of grid and source and exit points (just x coordinate)\n     * for water. Places source of water and bucket on selected points, and obsidian everywhere else\n     */\n    initBucketGrid(size, sourceArray, exitArray) {\n        const HEIGHT = 2;\n        this.bucketGrid = new Array(HEIGHT);\n        for (var i = 0; i < HEIGHT; i++) {\n            this.bucketGrid[i] = new Array(size);\n            for(var j=0; j<size; j++) {\n                this.bucketGrid[i][j] = new Block(\"air\");\n            }\n        }\n        for (let source in sourceArray) {\n            this.bucketGrid[0][source] = \"water\";\n        }\n        for (let exit in exitArray) {\n            this.bucketGrid[1][exit] = \"buck\";\n        }\n    }\n    /** Function returns boolean if block above bucket has water, representing win\n    */\n    checkForWin(grid, bucketGrid) {\n        let bucketLoc\n        console.log(bucketGrid);\n        for (let i = 0; i < bucketGrid[1].length; i++) {\n            if (i === \"buck\") {\n                bucketLoc = i;\n            }\n        }\n        let previousBlock = grid[grid.length-1][bucketLoc].blockType;\n        if (previousBlock === \"water\" || previousBlock === \"fixw\") {\n            return true;\n        }\n        return false;\n    }\n\n\n    printGrid() {\n        if (this.notupdated) throw new Error(\"not updated!\");\n        process.stdout.write(\"-----------------------------\\n\");\n        for(var i=0; i< this.grid.length; i++) {\n            for(var j=0; j< this.grid[i].length; j++) {\n                process.stdout.write(this.grid[i][j].print() + \"  \");\n            }\n            process.stdout.write(\"|\\n\");\n        }\n        process.stdout.write(\"-----------------------------\\n\");\n    }\n    /*\n    updateGrid() {\n        for(var i=0; i< this.grid.length-1; i++) {\n            for(var j=0; j< this.grid[i].length; j++) {\n                if ( this.grid[i][j].blockType === \"water\") {\n                    if ( this.grid[i+1][j].blockType === \"air\") {\n                         this.grid[i+1][j].blockType = 4;\n                    } else if ( this.grid[i+1][j].blockType === \"stone\") {\n                        if ( this.grid[i][j-1].blockType === \"air\")  this.grid[i][j-1] = 4;\n                        if ( this.grid[i][j+1].blockType === \"air\")  this.grid[i][j+1] = 4;\n                    }\n                    this.grid[i][j] = new Block(\"fixw\");\n                }\n            }\n        }\n        for(i=0; i< this.grid.length; i++) {\n            for(j=0; j< this.grid[i].length; j++) {\n                if ( this.grid[i][j].blockType === 4)  this.grid[i][j] = new Block(\"water\");\n            }\n        }\n        \n    }*/\n\n    updateGrid() {\n        this.updateAllNeighborBlock();\n        this.updateAllBlock();\n    }\n    updateAllNeighborBlock() {\n        for(let i=0; i< this.grid.length; i++) {\n            for(let j=0; j< this.grid[i].length; j++) {\n                this.updateNeighborBlock(i, j);\n            }\n        }\n    }\n    /*\n    updateNeighborBlock(x, y) {\n        let nowBlock = this.grid[x][y];\n        if (nowBlock.blockType !== \"water\") return;\n        if (nowBlock.downFlow) {\n            if (x+1 >= this.grid.length) return; // last row\n            if (x+2 >= this.grid.length || this.grid[x+2][y].blockType === \"air\" || this.grid[x+2][y].blockType === \"water\") {\n                this.grid[x+1][y].initDownFlowWater();\n            } else if (this.grid[x+2][y].blockType === \"stone\") {\n                if (this.grid[x+1][y].blockType === \"air\") {\n                    this.grid[x+1][y].initWater(7, 7);\n                } else if (this.grid[x+1][y].blockType === \"water\") {\n                    this.grid[x+1][y].heighten(7, 7);\n                    //hsidofisd\n                } else {\n                    throw new Error(\"strange error 1\");\n                }\n            } else {\n                throw new Error(\"unknown block type\");\n            }\n        } else {\n            if (x === this.grid.length-1 || this.grid[x+1][y].blockType !== \"stone\")  {\n                this.grid[x+1][y].initDownFlowWater();\n            } else {\n                if (y > 0) {\n                    if (this.grid[x][y-1].blockType === \"air\") {\n                        this.grid[x][y-1].initWater(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                    } else {\n                        this.grid[x][y-1].heighten(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                    }\n                }\n                if (y < this.grid[x].length - 1) {\n                    if (this.grid[x][y+1].blockType === \"air\") {\n                        console.log(this.grid[x][y+1]);\n                        console.log(this.grid[x][y+1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1));\n                        this.grid[x][y+1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                    } else {\n                        this.grid[x][y+1].heighten(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                    }\n                }\n            }\n            \n        }\n    }*/\n    updateNeighborBlock(x, y) {\n        let nowBlock = this.grid[x][y];\n        if (x<0 || x>= this.grid.length || y<0 || y>=this.grid[0]) throw new Error(\"x, y not in range\");\n        if (nowBlock.blockType !== \"water\") return;\n\n\n        if (x === this.grid.length-1) {\n            return;\n        } else if (this.grid[x+1][y].blockType !== \"stone\") {\n            if (this.grid[x+1][y].blockType === \"air\") {\n                this.grid[x+1][y].initWater(7, 7);\n            } else if (this.grid[x+1][y].blockType === \"water\") {\n                this.grid[x+1][y].heighten(7, 7);\n                //hsidofisd\n            } else {\n                throw new Error(\"strange error 1\");\n            }\n        } else {\n            if (y > 0) {\n                if (this.grid[x][y-1].blockType === \"air\") {\n                    this.grid[x][y-1].initWater(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                } else {\n                    this.grid[x][y-1].heighten(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                }\n            }\n            if (y < this.grid[x].length - 1) {\n                if (this.grid[x][y+1].blockType === \"air\") {\n                    this.grid[x][y+1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                } else {\n                    this.grid[x][y+1].heighten(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                }\n            }\n        }\n    }\n    updateAllBlock() {\n        for(let i=0; i< this.grid.length; i++) {\n            for(let j=0; j< this.grid[i].length; j++) {\n                this.grid[i][j].update();\n            }\n        }\n        this.notupdated = false;\n    }\n    \n\n//shouldnt this be grid[y][x]?\n    placeWater(x, y) {\n        this.notupdated = true;\n        if (x !== 0) throw new Error(\"you can only place water at top row\");\n        this.grid[x][y].initWater(7, 7);\n        /*if (this.grid[x+1][y].blockType === \"stone\") {\n            this.grid[x][y].initWater(7, 7);\n        } else {\n            this.grid[x][y].initDownFlowWater();\n        }*/\n    }\n    // test code end\n\n    done() { //check sides, check split paths\n        for(var x=0; x< this.grid.length; x++) {\n            for(var y=0; y< this.grid[x].length; y++) {\n                if (this.grid[x][y].blockType !== \"water\") continue;\n                if (x === this.grid.length-1) continue;\n                if (this.grid[x+1][y].blockType === \"air\") return false;\n                else if (this.grid[x+1][y].blockType === \"stone\") {\n                    if (y > 0) {\n                        if (this.grid[x][y-1].blockType === \"air\") return false\n                    }\n                    if (y < this.grid[x].length - 1) {\n                        if (this.grid[x][y+1].blockType === \"air\") return false\n                    }\n                }\n            }\n        }\n        return true\n        for (let i = 0; i <  this.grid[0].length; i++) {\n            if ( this.grid[this.grid.length-1][i].blockType === \"water\" ||  this.grid[this.grid.length-1][i].blockType === \"fixw\") {\n                return true\n            }\n        }\n        return false\n    }\n\n    /*placeBlock(x, y, material) {\n        this.grid[y][x] = new Block(material);\n    }*/\n    getIndex(x, y) {\n        return (\n          this.grid[y][x]\n        )\n    }\n}\n//test code 1 start\nlet game = new GameGrid(8);\ngame.placeBlock(4, 3, 'stone');\n\nexport default GameGrid;",["17","18"],"/home/johndoe/Documents/GT/HackGT/DisHackGT8/Discere-Hack-GT-8/HackGT8-2/HackGT8/src/WaterLogic.js",[],{"ruleId":"19","severity":1,"message":"20","line":259,"column":9,"nodeType":"21","messageId":"22","endLine":264,"endColumn":21},{"ruleId":"23","replacedBy":"24"},{"ruleId":"25","replacedBy":"26"},"no-unreachable","Unreachable code.","ForStatement","unreachableCode","no-native-reassign",["27"],"no-negated-in-lhs",["28"],"no-global-assign","no-unsafe-negation"]