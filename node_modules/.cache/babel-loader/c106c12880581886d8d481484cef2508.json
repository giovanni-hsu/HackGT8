{"ast":null,"code":"/**Types of blocks: \"air\"; \"stone\"; \"water\"; \"fixw\"; \"buck\"; \"obsi\"\n * 0 Air\n * 1 Stone\n * 2 Water\n * 3 Fixed water\n */\n\n/** Function takes in grid, coordinates and type of block to be placed\n * returns boolean representing success / failure\n */\nimport Block from './WaterLogic.js';\n\nclass GameGrid {\n  constructor(size) {\n    this.size = size;\n    this.grid = this.intializeGrid(size);\n    this.bucketGrid = null;\n    this.numToIcon = {\n      \"air\": \" \",\n      \"stone\": \"#\",\n      \"water\": \"o\",\n      \"fixw\": \"o\"\n    };\n  }\n\n  getSize() {\n    return this.size;\n  }\n\n  placeBlock(x, y, type) {\n    if (this.grid[y][x].blockType === \"air\") {\n      this.grid[y][x] = new Block(type);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /** Function takes in grid and replaces water blocks with air blocks\n   */\n\n\n  resetGrid() {\n    for (let x = 0; x < this.grid.length; x++) {\n      for (let y = 0; y < this.grid.length; y++) {\n        if (this.grid[y][x].blockType === \"water\" || this.grid[y][x].blockType === \"fixw\") {\n          this.grid[y][x] = new Block(\"air\");\n        }\n      }\n    }\n  }\n\n  intializeGrid() {\n    var grid = new Array(this.size);\n\n    for (var i = 0; i < this.size; i++) {\n      grid[i] = new Array(this.size);\n\n      for (var j = 0; j < this.size; j++) {\n        grid[i][j] = new Block(\"air\");\n      }\n    }\n\n    return grid;\n  }\n  /** Function initializes bucket grid, taking in as input size of grid and source and exit points (just x coordinate)\n   * for water. Places source of water and bucket on selected points, and obsidian everywhere else\n   */\n\n\n  initBucketGrid(size, sourceArray, exitArray) {\n    const HEIGHT = 2;\n    this.bucketGrid = new Array(HEIGHT);\n\n    for (var i = 0; i < HEIGHT; i++) {\n      this.bucketGrid[i] = new Array(size);\n\n      for (var j = 0; j < size; j++) {\n        this.bucketGrid[i][j] = new Block(\"air\");\n      }\n    }\n\n    for (let source in sourceArray) {\n      this.bucketGrid[0][source] = \"water\";\n    }\n\n    for (let exit in exitArray) {\n      this.bucketGrid[1][exit] = \"buck\";\n    }\n  }\n  /** Function returns boolean if block above bucket has water, representing win\n  */\n\n\n  checkForWin(grid, bucketGrid) {\n    let bucketLoc;\n    console.log(bucketGrid);\n\n    for (let i = 0; i < bucketGrid[1].length; i++) {\n      if (i === \"buck\") {\n        bucketLoc = i;\n      }\n    }\n\n    let previousBlock = grid[grid.length - 1][bucketLoc].blockType;\n\n    if (previousBlock === \"water\" || previousBlock == \"fixw\") {\n      return true;\n    }\n\n    return false;\n  }\n\n  printGrid() {\n    process.stdout.write(\"-----------------------------\\n\");\n\n    for (var i = 0; i < this.grid.length; i++) {\n      for (var j = 0; j < this.grid[i].length; j++) {\n        process.stdout.write(this.grid[i][j].print() + \"  \");\n      }\n\n      process.stdout.write(\"|\\n\");\n    }\n\n    process.stdout.write(\"-----------------------------\\n\");\n  }\n\n  updateGrid() {\n    for (var i = 0; i < this.grid.length - 1; i++) {\n      for (var j = 0; j < this.grid[i].length; j++) {\n        if (this.grid[i][j].blockType === \"water\") {\n          if (this.grid[i + 1][j].blockType === \"air\") {\n            this.grid[i + 1][j].blockType = 4;\n          } else if (this.grid[i + 1][j].blockType === \"stone\") {\n            if (this.grid[i][j - 1].blockType === \"air\") this.grid[i][j - 1] = 4;\n            if (this.grid[i][j + 1].blockType === \"air\") this.grid[i][j + 1] = 4;\n          }\n\n          this.grid[i][j] = new Block(\"fixw\");\n        }\n      }\n    }\n\n    for (i = 0; i < this.grid.length; i++) {\n      for (j = 0; j < this.grid[i].length; j++) {\n        if (this.grid[i][j].blockType === 4) this.grid[i][j] = new Block(\"water\");\n      }\n    }\n  }\n\n  updateGrid() {\n    this.updateAllNeighborBlock();\n    this.updateAllBlock();\n  }\n\n  updateAllNeighborBlock() {\n    for (let i = 0; i < this.grid.length; i++) {\n      for (let j = 0; j < this.grid[i].length; j++) {\n        this.updateNeighborBlock(i, j);\n      }\n    }\n  }\n\n  updateNeighborBlock(x, y) {\n    let nowBlock = this.grid[x][y];\n    if (nowBlock.blockType != \"water\") return;\n\n    if (nowBlock.downFlow) {\n      if (x + 1 >= this.grid.length) return; // last row\n\n      if (x + 2 >= this.grid.length || this.grid[x + 2][y].blockType == \"air\" || this.grid[x + 2][y].blockType == \"water\") {\n        this.grid[x + 1][y].initDownFlowWater();\n      } else if (this.grid[x + 2][y].blockType == \"stone\") {\n        if (this.grid[x + 1][y].blockType == \"air\") {\n          this.grid[x + 1][y].initWater(7, 7);\n        } else if (this.grid[x + 1][y].blockType == \"water\") {\n          this.grid[x + 1][y].heighten(7, 7);\n        } else {\n          throw \"strange error 1\";\n        }\n      } else {\n        throw \"unknown block type\";\n      }\n    } else {\n      if (y > 0) {\n        if (this.grid[x][y - 1].blockType == \"air\") {\n          this.grid[x][y - 1].initWater(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n        } else {\n          this.grid[x][y - 1].heighten(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n        }\n      }\n\n      if (y < this.grid[x].length - 1) {\n        if (this.grid[x][y + 1].blockType == \"air\") {\n          console.log(this.grid[x][y + 1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1));\n          this.grid[x][y + 1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n        } else {\n          this.grid[x][y + 1].heighten(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n        }\n      }\n    }\n  }\n\n  updateAllBlock() {\n    for (let i = 0; i < this.grid.length; i++) {\n      for (let j = 0; j < this.grid[i].length; j++) {\n        this.gird[i][j].update();\n      }\n    }\n  } //shouldnt this be grid[y][x]?\n\n\n  placeWater(x, y) {\n    this.grid[y][x] = new Block(\"water\");\n  } // test code end\n\n\n  done() {\n    //check sides, check split paths\n    for (let i = 0; i < this.grid[0].length; i++) {\n      if (this.grid[this.grid.length - 1][i].blockType === \"water\" || this.grid[this.grid.length - 1][i].blockType === \"fixw\") {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  placeBlock(x, y, material) {\n    this.grid[y][x] = new Block(material);\n  }\n\n  getIndex(x, y) {\n    return this.grid[y][x];\n  }\n\n} //test code 1 start\n\n\nlet game = new GameGrid(8);\ngame.placeBlock(4, 3, 'stone');\nexport default GameGrid;","map":{"version":3,"sources":["/Users/maxliu/Desktop/HackGT8/src/GameLogic.js"],"names":["Block","GameGrid","constructor","size","grid","intializeGrid","bucketGrid","numToIcon","getSize","placeBlock","x","y","type","blockType","resetGrid","length","Array","i","j","initBucketGrid","sourceArray","exitArray","HEIGHT","source","exit","checkForWin","bucketLoc","console","log","previousBlock","printGrid","process","stdout","write","print","updateGrid","updateAllNeighborBlock","updateAllBlock","updateNeighborBlock","nowBlock","downFlow","initDownFlowWater","initWater","heighten","waterLevel","gird","update","placeWater","done","material","getIndex","game"],"mappings":"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","sourcesContent":["/**Types of blocks: \"air\"; \"stone\"; \"water\"; \"fixw\"; \"buck\"; \"obsi\"\n * 0 Air\n * 1 Stone\n * 2 Water\n * 3 Fixed water\n */\n\n/** Function takes in grid, coordinates and type of block to be placed\n * returns boolean representing success / failure\n */\nimport Block from './WaterLogic.js';\n\nclass GameGrid {\n\n    constructor(size) {\n        this.size = size;\n        this.grid = this.intializeGrid(size);\n        this.bucketGrid = null;\n        this.numToIcon = {\"air\":\" \", \"stone\":\"#\", \"water\":\"o\", \"fixw\":\"o\"};\n    }\n\n    getSize() {\n        return this.size;\n    }\n\n    placeBlock(x, y, type) {\n       if (this.grid[y][x].blockType === \"air\") {\n            this.grid[y][x] = new Block(type);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /** Function takes in grid and replaces water blocks with air blocks\n     */\n    resetGrid() {\n        for (let x = 0; x <  this.grid.length; x++) {\n            for (let y = 0; y <  this.grid.length; y++) {\n                if ( this.grid[y][x].blockType === \"water\" || this.grid[y][x].blockType === \"fixw\") {\n                     this.grid[y][x] = new Block(\"air\");\n                }\n            }\n        }\n    }\n\n    intializeGrid() {\n        var grid = new Array(this.size);\n        for (var i = 0; i < this.size; i++) {\n            grid[i] = new Array(this.size);\n            for(var j=0; j<this.size; j++) {\n                grid[i][j] = new Block(\"air\");\n            }\n        }\n        return grid;\n    }\n\n    /** Function initializes bucket grid, taking in as input size of grid and source and exit points (just x coordinate)\n     * for water. Places source of water and bucket on selected points, and obsidian everywhere else\n     */\n    initBucketGrid(size, sourceArray, exitArray) {\n        const HEIGHT = 2;\n        this.bucketGrid = new Array(HEIGHT);\n        for (var i = 0; i < HEIGHT; i++) {\n            this.bucketGrid[i] = new Array(size);\n            for(var j=0; j<size; j++) {\n                this.bucketGrid[i][j] = new Block(\"air\");\n            }\n        }\n        for (let source in sourceArray) {\n            this.bucketGrid[0][source] = \"water\";\n        }\n        for (let exit in exitArray) {\n            this.bucketGrid[1][exit] = \"buck\";\n        }\n    }\n    /** Function returns boolean if block above bucket has water, representing win\n    */\n    checkForWin(grid, bucketGrid) {\n        let bucketLoc\n        console.log(bucketGrid);\n        for (let i = 0; i < bucketGrid[1].length; i++) {\n            if (i === \"buck\") {\n                bucketLoc = i;\n            }\n        }\n        let previousBlock = grid[grid.length-1][bucketLoc].blockType;\n        if (previousBlock === \"water\" || previousBlock == \"fixw\") {\n            return true;\n        }\n        return false;\n    }\n\n\n    printGrid() {\n        process.stdout.write(\"-----------------------------\\n\");\n        for(var i=0; i< this.grid.length; i++) {\n            for(var j=0; j< this.grid[i].length; j++) {\n                process.stdout.write(this.grid[i][j].print() + \"  \");\n            }\n            process.stdout.write(\"|\\n\");\n        }\n        process.stdout.write(\"-----------------------------\\n\");\n    }\n\n    updateGrid() {\n        for(var i=0; i< this.grid.length-1; i++) {\n            for(var j=0; j< this.grid[i].length; j++) {\n                if ( this.grid[i][j].blockType === \"water\") {\n                    if ( this.grid[i+1][j].blockType === \"air\") {\n                         this.grid[i+1][j].blockType = 4;\n                    } else if ( this.grid[i+1][j].blockType === \"stone\") {\n                        if ( this.grid[i][j-1].blockType === \"air\")  this.grid[i][j-1] = 4;\n                        if ( this.grid[i][j+1].blockType === \"air\")  this.grid[i][j+1] = 4;\n                    }\n                    this.grid[i][j] = new Block(\"fixw\");\n                }\n            }\n        }\n        for(i=0; i< this.grid.length; i++) {\n            for(j=0; j< this.grid[i].length; j++) {\n                if ( this.grid[i][j].blockType === 4)  this.grid[i][j] = new Block(\"water\");\n            }\n        }\n        \n    }\n\n    updateGrid() {\n        this.updateAllNeighborBlock();\n        this.updateAllBlock();\n    }\n    updateAllNeighborBlock() {\n        for(let i=0; i< this.grid.length; i++) {\n            for(let j=0; j< this.grid[i].length; j++) {\n                this.updateNeighborBlock(i, j);\n            }\n        }\n    }\n    updateNeighborBlock(x, y) {\n        let nowBlock = this.grid[x][y];\n        if (nowBlock.blockType != \"water\") return;\n        if (nowBlock.downFlow) {\n            if (x+1 >= this.grid.length) return; // last row\n            if (x+2 >= this.grid.length || this.grid[x+2][y].blockType == \"air\" || this.grid[x+2][y].blockType == \"water\") {\n                this.grid[x+1][y].initDownFlowWater();\n            } else if (this.grid[x+2][y].blockType == \"stone\") {\n                if (this.grid[x+1][y].blockType == \"air\") {\n                    this.grid[x+1][y].initWater(7, 7);\n                } else if (this.grid[x+1][y].blockType == \"water\") {\n                    this.grid[x+1][y].heighten(7, 7);\n                } else {\n                    throw \"strange error 1\"\n                }\n            } else {\n                throw \"unknown block type\";\n            }\n        } else {\n            if (y > 0) {\n                if (this.grid[x][y-1].blockType == \"air\") {\n                    this.grid[x][y-1].initWater(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                } else {\n                    this.grid[x][y-1].heighten(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                }\n            }\n            if (y < this.grid[x].length - 1) {\n                if (this.grid[x][y+1].blockType == \"air\") {\n                    console.log(this.grid[x][y+1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1));\n                    this.grid[x][y+1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                } else {\n                    this.grid[x][y+1].heighten(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                }\n            }\n        }\n    }\n    updateAllBlock() {\n        for(let i=0; i< this.grid.length; i++) {\n            for(let j=0; j< this.grid[i].length; j++) {\n                this.gird[i][j].update();\n            }\n        }\n    }\n    \n\n//shouldnt this be grid[y][x]?\n    placeWater(x, y) {\n         this.grid[y][x] = new Block(\"water\");\n    }\n    // test code end\n\n    done() { //check sides, check split paths\n        for (let i = 0; i <  this.grid[0].length; i++) {\n            if ( this.grid[this.grid.length-1][i].blockType === \"water\" ||  this.grid[this.grid.length-1][i].blockType === \"fixw\") {\n                return true\n            }\n        }\n        return false\n    }\n\n    placeBlock(x, y, material) {\n        this.grid[y][x] = new Block(material);\n    }\n    getIndex(x, y) {\n        return (\n          this.grid[y][x]\n        )\n      }\n}\n//test code 1 start\nlet game = new GameGrid(8);\ngame.placeBlock(4, 3, 'stone');\n\nexport default GameGrid;"]},"metadata":{},"sourceType":"module"}