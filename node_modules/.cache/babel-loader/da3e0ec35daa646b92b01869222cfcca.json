{"ast":null,"code":"/**Types of blocks: \"air\"; \"stone\"; \"water\"; \"fixw\"; \"buck\"; \"obsi\"\n * 0 Air\n * 1 Stone\n * 2 Water\n * 3 Fixed water\n */\n\n/** Function takes in grid, coordinates and type of block to be placed\n * returns boolean representing success / failure\n */\nclass GameGrid {\n  constructor(size) {\n    this.size = size;\n    this.grid = this.intializeGrid(size);\n    this.bucketGrid = null;\n    this.numToIcon = {\n      \"air\": \" \",\n      \"stone\": \"#\",\n      \"water\": \"o\",\n      \"fixw\": \"o\"\n    };\n  }\n\n  getSize() {\n    return this.size;\n  }\n\n  placeBlock(x, y, type) {\n    if (this.grid[y][x].blockType === \"air\") {\n      this.grid[y][x] = new Block(type);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /** Function takes in grid and replaces water blocks with air blocks\n   */\n\n\n  resetGrid() {\n    for (let x = 0; x < this.grid.length; x++) {\n      for (let y = 0; y < this.grid.length; y++) {\n        if (this.grid[y][x].blockType === \"water\" || this.grid[y][x].blockType === \"fixw\") {\n          this.grid[y][x] = new Block(\"air\");\n        }\n      }\n    }\n  }\n\n  intializeGrid() {\n    var grid = new Array(this.size);\n\n    for (var i = 0; i < this.size; i++) {\n      grid[i] = new Array(this.size);\n\n      for (var j = 0; j < this.size; j++) {\n        grid[i][j] = new Block(\"air\");\n      }\n    }\n\n    return grid;\n  }\n  /** Function initializes bucket grid, taking in as input size of grid and source and exit points (just x coordinate)\n   * for water. Places source of water and bucket on selected points, and obsidian everywhere else\n   */\n\n\n  initBucketGrid(size, sourceArray, exitArray) {\n    const HEIGHT = 2;\n    this.bucketGrid = new Array(HEIGHT);\n\n    for (var i = 0; i < HEIGHT; i++) {\n      this.bucketGrid[i] = new Array(size);\n\n      for (var j = 0; j < size; j++) {\n        this.bucketGrid[i][j] = new Block(\"air\");\n      }\n    }\n\n    for (let source in sourceArray) {\n      this.bucketGrid[0][source] = \"water\";\n    }\n\n    for (let exit in exitArray) {\n      this.bucketGrid[1][exit] = \"buck\";\n    }\n  }\n  /** Function returns boolean if block above bucket has water, representing win\n  */\n\n\n  checkForWin(grid, bucketGrid) {\n    let bucketLoc;\n    console.log(bucketGrid);\n\n    for (let i = 0; i < bucketGrid[1].length; i++) {\n      if (i === \"buck\") {\n        bucketLoc = i;\n      }\n    }\n\n    let previousBlock = grid[grid.length - 1][bucketLoc].blockType;\n\n    if (previousBlock === \"water\" || previousBlock == \"fixw\") {\n      return true;\n    }\n\n    return false;\n  }\n\n  printGrid() {\n    process.stdout.write(\"-----------------------------\\n\");\n\n    for (var i = 0; i < this.grid.length; i++) {\n      for (var j = 0; j < this.grid[i].length; j++) {\n        process.stdout.write(this.grid[i][j].print() + \"  \");\n      }\n\n      process.stdout.write(\"|\\n\");\n    }\n\n    process.stdout.write(\"-----------------------------\\n\");\n  }\n\n  updateGrid() {\n    for (var i = 0; i < this.grid.length - 1; i++) {\n      for (var j = 0; j < this.grid[i].length; j++) {\n        if (this.grid[i][j].blockType === \"water\") {\n          if (this.grid[i + 1][j].blockType === \"air\") {\n            this.grid[i + 1][j].blockType = 4;\n          } else if (this.grid[i + 1][j].blockType === \"stone\") {\n            if (this.grid[i][j - 1].blockType === \"air\") this.grid[i][j - 1] = 4;\n            if (this.grid[i][j + 1].blockType === \"air\") this.grid[i][j + 1] = 4;\n          }\n\n          this.grid[i][j] = new Block(\"fixw\");\n        }\n      }\n    }\n\n    for (i = 0; i < this.grid.length; i++) {\n      for (j = 0; j < this.grid[i].length; j++) {\n        if (this.grid[i][j].blockType === 4) this.grid[i][j] = new Block(\"water\");\n      }\n    }\n  }\n\n  updateGrid() {\n    updateAllNeighborBlock();\n    updateAllBlock();\n  }\n\n  updateAllNeighborBlock() {\n    for (i = 0; i < this.grid.length; i++) {\n      for (j = 0; j < this.grid[i].length; j++) {\n        this.updateNeighborBlock(i, j);\n      }\n    }\n  }\n\n  updateNeighborBlock(x, y) {\n    nowBlock = this.grid[x][y];\n    if (nowBlock.blockType != \"water\") return;\n\n    if (nowBlock.downFlow) {\n      if (x + 1 >= this.grid.length) return; // last row\n\n      if (x + 2 >= this.grid.length || this.grid[x + 2][y].blockType == \"air\" || this.grid[x + 2][y].blockType == \"water\") {\n        this.grid[x + 1][y].initDownFlowWater();\n      } else if (this.grid[x + 2][y].blockType == \"stone\") {\n        if (this.grid[x + 1][y].blockType == \"air\") {\n          this.grid[x + 1][y].initWater(7, 7);\n        } else if (this.grid[x + 1][y].blockType == \"water\") {\n          this.grid[x + 1][y].heighten(7, 7);\n        } else {\n          throw \"strange error 1\";\n        }\n      } else {\n        throw \"unknown block type\";\n      }\n    } else {\n      if (y > 0) {\n        if (this.grid[x][y - 1].blockType == \"air\") {\n          this.grid[x][y - 1].initWater(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n        } else {\n          this.grid[x][y - 1].heighten(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n        }\n      }\n\n      if (y < this.grid[x].length - 1) {\n        if (this.grid[x][y + 1].blockType == \"air\") {\n          this.grid[x][y + 1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n        } else {\n          this.grid[x][y + 1].heighten(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n        }\n      }\n    }\n  }\n\n  updateAllBlock() {\n    for (i = 0; i < this.grid.length; i++) {\n      for (j = 0; j < this.grid[i].length; j++) {\n        this.gird[i][j].update();\n      }\n    }\n  } //shouldnt this be grid[y][x]?\n\n\n  placeWater(x, y) {\n    this.grid[y][x] = new Block(\"water\");\n  } // test code end\n\n\n  done() {\n    //check sides, check split paths\n    for (let i = 0; i < this.grid[0].length; i++) {\n      if (this.grid[this.grid.length - 1][i].blockType === \"water\" || this.grid[this.grid.length - 1][i].blockType === \"fixw\") {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  placeBlock(x, y, material) {\n    this.grid[y][x] = material;\n  }\n\n  getIndex(x, y) {\n    return this.grid[y][x];\n  }\n\n} //test code 1 start\n\n\ngame = new GameGrid(8);\ngame.placeStone(4, 3); //export default GameGrid","map":{"version":3,"sources":["/Users/maxliu/Desktop/HackGT8/src/GameLogic.js"],"names":["GameGrid","constructor","size","grid","intializeGrid","bucketGrid","numToIcon","getSize","placeBlock","x","y","type","blockType","Block","resetGrid","length","Array","i","j","initBucketGrid","sourceArray","exitArray","HEIGHT","source","exit","checkForWin","bucketLoc","console","log","previousBlock","printGrid","process","stdout","write","print","updateGrid","updateAllNeighborBlock","updateAllBlock","updateNeighborBlock","nowBlock","downFlow","initDownFlowWater","initWater","heighten","waterLevel","gird","update","placeWater","done","material","getIndex","game","placeStone"],"mappings":"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","sourcesContent":["/**Types of blocks: \"air\"; \"stone\"; \"water\"; \"fixw\"; \"buck\"; \"obsi\"\n * 0 Air\n * 1 Stone\n * 2 Water\n * 3 Fixed water\n */\n\n/** Function takes in grid, coordinates and type of block to be placed\n * returns boolean representing success / failure\n */\nclass GameGrid {\n\n    constructor(size) {\n        this.size = size;\n        this.grid = this.intializeGrid(size);\n        this.bucketGrid = null;\n        this.numToIcon = {\"air\":\" \", \"stone\":\"#\", \"water\":\"o\", \"fixw\":\"o\"};\n    }\n\n    getSize() {\n        return this.size;\n    }\n\n    placeBlock(x, y, type) {\n       if (this.grid[y][x].blockType === \"air\") {\n            this.grid[y][x] = new Block(type);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /** Function takes in grid and replaces water blocks with air blocks\n     */\n    resetGrid() {\n        for (let x = 0; x <  this.grid.length; x++) {\n            for (let y = 0; y <  this.grid.length; y++) {\n                if ( this.grid[y][x].blockType === \"water\" || this.grid[y][x].blockType === \"fixw\") {\n                     this.grid[y][x] = new Block(\"air\");\n                }\n            }\n        }\n    }\n\n    intializeGrid() {\n        var grid = new Array(this.size);\n        for (var i = 0; i < this.size; i++) {\n            grid[i] = new Array(this.size);\n            for(var j=0; j<this.size; j++) {\n                grid[i][j] = new Block(\"air\");\n            }\n        }\n        return grid;\n    }\n\n    /** Function initializes bucket grid, taking in as input size of grid and source and exit points (just x coordinate)\n     * for water. Places source of water and bucket on selected points, and obsidian everywhere else\n     */\n    initBucketGrid(size, sourceArray, exitArray) {\n        const HEIGHT = 2;\n        this.bucketGrid = new Array(HEIGHT);\n        for (var i = 0; i < HEIGHT; i++) {\n            this.bucketGrid[i] = new Array(size);\n            for(var j=0; j<size; j++) {\n                this.bucketGrid[i][j] = new Block(\"air\");\n            }\n        }\n        for (let source in sourceArray) {\n            this.bucketGrid[0][source] = \"water\";\n        }\n        for (let exit in exitArray) {\n            this.bucketGrid[1][exit] = \"buck\";\n        }\n    }\n    /** Function returns boolean if block above bucket has water, representing win\n    */\n    checkForWin(grid, bucketGrid) {\n        let bucketLoc\n        console.log(bucketGrid);\n        for (let i = 0; i < bucketGrid[1].length; i++) {\n            if (i === \"buck\") {\n                bucketLoc = i;\n            }\n        }\n        let previousBlock = grid[grid.length-1][bucketLoc].blockType;\n        if (previousBlock === \"water\" || previousBlock == \"fixw\") {\n            return true;\n        }\n        return false;\n    }\n\n\n    printGrid() {\n        process.stdout.write(\"-----------------------------\\n\");\n        for(var i=0; i< this.grid.length; i++) {\n            for(var j=0; j< this.grid[i].length; j++) {\n                process.stdout.write(this.grid[i][j].print() + \"  \");\n            }\n            process.stdout.write(\"|\\n\");\n        }\n        process.stdout.write(\"-----------------------------\\n\");\n    }\n\n    updateGrid() {\n        for(var i=0; i< this.grid.length-1; i++) {\n            for(var j=0; j< this.grid[i].length; j++) {\n                if ( this.grid[i][j].blockType === \"water\") {\n                    if ( this.grid[i+1][j].blockType === \"air\") {\n                         this.grid[i+1][j].blockType = 4;\n                    } else if ( this.grid[i+1][j].blockType === \"stone\") {\n                        if ( this.grid[i][j-1].blockType === \"air\")  this.grid[i][j-1] = 4;\n                        if ( this.grid[i][j+1].blockType === \"air\")  this.grid[i][j+1] = 4;\n                    }\n                    this.grid[i][j] = new Block(\"fixw\");\n                }\n            }\n        }\n        for(i=0; i< this.grid.length; i++) {\n            for(j=0; j< this.grid[i].length; j++) {\n                if ( this.grid[i][j].blockType === 4)  this.grid[i][j] = new Block(\"water\");\n            }\n        }\n        \n    }\n\n    updateGrid() {\n        updateAllNeighborBlock();\n        updateAllBlock();\n    }\n    updateAllNeighborBlock() {\n        for(i=0; i< this.grid.length; i++) {\n            for(j=0; j< this.grid[i].length; j++) {\n                this.updateNeighborBlock(i, j);\n            }\n        }\n    }\n    updateNeighborBlock(x, y) {\n        nowBlock = this.grid[x][y];\n        if (nowBlock.blockType != \"water\") return;\n        if (nowBlock.downFlow) {\n            if (x+1 >= this.grid.length) return; // last row\n            if (x+2 >= this.grid.length || this.grid[x+2][y].blockType == \"air\" || this.grid[x+2][y].blockType == \"water\") {\n                this.grid[x+1][y].initDownFlowWater();\n            } else if (this.grid[x+2][y].blockType == \"stone\") {\n                if (this.grid[x+1][y].blockType == \"air\") {\n                    this.grid[x+1][y].initWater(7, 7);\n                } else if (this.grid[x+1][y].blockType == \"water\") {\n                    this.grid[x+1][y].heighten(7, 7);\n                } else {\n                    throw \"strange error 1\"\n                }\n            } else {\n                throw \"unknown block type\";\n            }\n        } else {\n            if (y > 0) {\n                if (this.grid[x][y-1].blockType == \"air\") {\n                    this.grid[x][y-1].initWater(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                } else {\n                    this.grid[x][y-1].heighten(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                }\n            }\n            if (y < this.grid[x].length - 1) {\n                if (this.grid[x][y+1].blockType == \"air\") {\n                    this.grid[x][y+1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                } else {\n                    this.grid[x][y+1].heighten(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                }\n            }\n        }\n    }\n    updateAllBlock() {\n        for(i=0; i< this.grid.length; i++) {\n            for(j=0; j< this.grid[i].length; j++) {\n                this.gird[i][j].update();\n            }\n        }\n    }\n    \n\n//shouldnt this be grid[y][x]?\n    placeWater(x, y) {\n         this.grid[y][x] = new Block(\"water\");\n    }\n    // test code end\n\n    done() { //check sides, check split paths\n        for (let i = 0; i <  this.grid[0].length; i++) {\n            if ( this.grid[this.grid.length-1][i].blockType === \"water\" ||  this.grid[this.grid.length-1][i].blockType === \"fixw\") {\n                return true\n            }\n        }\n        return false\n    }\n\n    placeBlock(x, y, material) {\n        this.grid[y][x] = material;\n    }\n    getIndex(x, y) {\n        return (\n          this.grid[y][x]\n        )\n      }\n}\n//test code 1 start\ngame = new GameGrid(8);\ngame.placeStone(4, 3);\n\n//export default GameGrid"]},"metadata":{},"sourceType":"module"}