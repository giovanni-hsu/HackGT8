{"ast":null,"code":"/**Types of blocks: \"air\"; \"stone\"; \"water\"; \"fixw\"; \"buck\"; \"obsi\"\n * 0 Air\n * 1 Stone\n * 2 Water\n * 3 Fixed water\n */\n\n/** Function takes in grid, coordinates and type of block to be placed\n * returns boolean representing success / failure\n */\nclass GameGrid {\n  constructor(size) {\n    this.size = size;\n    this.grid = this.intializeGrid(size);\n    this.bucketGrid = null;\n    this.numToIcon = {\n      \"air\": \" \",\n      \"stone\": \"#\",\n      \"water\": \"o\",\n      \"fixw\": \"o\"\n    };\n  }\n\n  getSize() {\n    return this.size;\n  }\n\n  placeBlock(x, y, type) {\n    if (this.grid[y][x] === \"air\") {\n      this.grid[y][x] = type;\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /** Function takes in grid and replaces water blocks with air blocks\n   */\n\n\n  resetGrid() {\n    for (let x = 0; x < this.grid.length; x++) {\n      for (let y = 0; y < this.grid.length; y++) {\n        if (this.grid[y][x] === \"water\" || this.grid[y][x] === \"fixw\") {\n          this.grid[y][x] = \"air\";\n        }\n      }\n    }\n  }\n\n  intializeGrid() {\n    var grid = new Array(this.size);\n\n    for (var i = 0; i < this.size; i++) {\n      grid[i] = new Array(this.size);\n\n      for (var j = 0; j < this.size; j++) {\n        grid[i][j] = \"air\";\n      }\n    }\n\n    return grid;\n  }\n  /** Function initializes bucket grid, taking in as input size of grid and source and exit points (just x coordinate)\n   * for water. Places source of water and bucket on selected points, and obsidian everywhere else\n   */\n\n\n  initBucketGrid(size, sourceArray, exitArray) {\n    const HEIGHT = 2;\n    this.bucketGrid = new Array(HEIGHT);\n\n    for (var i = 0; i < HEIGHT; i++) {\n      this.bucketGrid[i] = new Array(size);\n\n      for (var j = 0; j < size; j++) {\n        this.bucketGrid[i][j] = \"air\";\n      }\n    }\n\n    for (source in sourceArray) {\n      this.bucketGrid[0][source] = \"water\";\n    }\n\n    for (exit in exitArray) {\n      this.bucketGrid[1][exit] = \"buck\";\n    }\n  }\n  /** Function returns boolean if block above bucket has water, representing win\n  */\n\n\n  checkForWin(grid, bucketGrid) {\n    let bucketLoc;\n\n    for (let i = 0; i < bucketGrid[1].length; i++) {\n      if (i === \"buck\") {\n        bucketLoc = i;\n      }\n    }\n\n    let previousBlock = grid[grid.length - 1][bucketLoc];\n\n    if (previousBlock === \"water\" || previousBlock == \"fixw\") {\n      return true;\n    }\n\n    return false;\n  }\n\n  printGrid() {\n    process.stdout.write(\"----------------\\n\");\n\n    for (var i = 0; i < this.grid.length; i++) {\n      for (var j = 0; j < this.grid[i].length; j++) {\n        process.stdout.write(this.numToIcon[this.grid[i][j]] + \" \");\n      }\n\n      process.stdout.write(\"|\\n\");\n    }\n\n    process.stdout.write(\"----------------\\n\");\n  }\n\n  updateGrid() {\n    for (var i = 0; i < this.grid.length - 1; i++) {\n      for (var j = 0; j < this.grid[i].length; j++) {\n        if (this.grid[i][j] === \"water\") {\n          if (this.grid[i + 1][j] === \"air\") {\n            this.grid[i + 1][j] = 4;\n          } else if (this.grid[i + 1][j] === \"stone\") {\n            if (this.grid[i][j - 1] === \"air\") this.grid[i][j - 1] = 4;\n            if (this.grid[i][j + 1] === \"air\") this.grid[i][j + 1] = 4;\n          }\n\n          this.grid[i][j] = \"fixw\";\n        }\n      }\n    }\n\n    for (i = 0; i < this.grid.length; i++) {\n      for (j = 0; j < this.grid[i].length; j++) {\n        if (this.grid[i][j] === 4) this.grid[i][j] = \"water\";\n      }\n    }\n  } // updateBlock(x, y) {\n  //     if (this.grid[x][y] != \"water\")\n  // }\n  //shouldnt this be grid[y][x]?\n\n\n  placeWater(x, y) {\n    this.grid[y][x] = \"water\";\n  } // test code end\n\n\n  done() {\n    //check sides, check split paths\n    for (let i = 0; i < this.grid[0].length; i++) {\n      if (this.grid[this.grid.length - 1][i] === \"water\" || this.grid[this.grid.length - 1][i] === \"fixw\") {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  placeStone(x, y) {\n    this.grid[y][x] = \"stone\";\n  }\n\n  getIndex(x, y) {\n    return this.grid[y][x];\n  }\n\n}\n\nexport default GameGrid;","map":{"version":3,"sources":["/Users/maxliu/Desktop/HackGT8/src/GameLogic.js"],"names":["GameGrid","constructor","size","grid","intializeGrid","bucketGrid","numToIcon","getSize","placeBlock","x","y","type","resetGrid","length","Array","i","j","initBucketGrid","sourceArray","exitArray","HEIGHT","source","exit","checkForWin","bucketLoc","previousBlock","printGrid","process","stdout","write","updateGrid","placeWater","done","placeStone","getIndex"],"mappings":"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","sourcesContent":["/**Types of blocks: \"air\"; \"stone\"; \"water\"; \"fixw\"; \"buck\"; \"obsi\"\n * 0 Air\n * 1 Stone\n * 2 Water\n * 3 Fixed water\n */\n\n/** Function takes in grid, coordinates and type of block to be placed\n * returns boolean representing success / failure\n */\nclass GameGrid {\n\n    constructor(size) {\n        this.size = size;\n        this.grid = this.intializeGrid(size);\n        this.bucketGrid = null;\n        this.numToIcon = {\"air\":\" \", \"stone\":\"#\", \"water\":\"o\", \"fixw\":\"o\"};\n    }\n\n    getSize() {\n        return this.size;\n    }\n\n    placeBlock(x, y, type) {\n        if (this.grid[y][x] === \"air\") {\n            this.grid[y][x] = type;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /** Function takes in grid and replaces water blocks with air blocks\n     */\n    resetGrid() {\n        for (let x = 0; x <  this.grid.length; x++) {\n            for (let y = 0; y <  this.grid.length; y++) {\n                if ( this.grid[y][x] === \"water\" || this.grid[y][x] === \"fixw\") {\n                     this.grid[y][x] = \"air\";\n                }\n            }\n        }\n    }\n\n    intializeGrid() {\n        var grid = new Array(this.size);\n        for (var i = 0; i < this.size; i++) {\n            grid[i] = new Array(this.size);\n            for(var j=0; j<this.size; j++) {\n                grid[i][j] = \"air\";\n            }\n        }\n        return grid;\n    }\n\n    /** Function initializes bucket grid, taking in as input size of grid and source and exit points (just x coordinate)\n     * for water. Places source of water and bucket on selected points, and obsidian everywhere else\n     */\n    initBucketGrid(size, sourceArray, exitArray) {\n        const HEIGHT = 2;\n        this.bucketGrid = new Array(HEIGHT);\n        for (var i = 0; i < HEIGHT; i++) {\n            this.bucketGrid[i] = new Array(size);\n            for(var j=0; j<size; j++) {\n                this.bucketGrid[i][j] = \"air\";\n            }\n        }\n        for (source in sourceArray) {\n            this.bucketGrid[0][source] = \"water\";\n        }\n        for (exit in exitArray) {\n            this.bucketGrid[1][exit] = \"buck\";\n        }\n    }\n    /** Function returns boolean if block above bucket has water, representing win\n    */\n    checkForWin(grid, bucketGrid) {\n        let bucketLoc\n        for (let i = 0; i < bucketGrid[1].length; i++) {\n            if (i === \"buck\") {\n                bucketLoc = i;\n            }\n        }\n        let previousBlock = grid[grid.length-1][bucketLoc];\n        if (previousBlock === \"water\" || previousBlock == \"fixw\") {\n            return true;\n        }\n        return false;\n    }\n\n\n    printGrid() {\n        process.stdout.write(\"----------------\\n\");\n        for(var i=0; i< this.grid.length; i++) {\n            for(var j=0; j< this.grid[i].length; j++) {\n                process.stdout.write(this.numToIcon[this.grid[i][j]] + \" \");\n            }\n            process.stdout.write(\"|\\n\");\n        }\n        process.stdout.write(\"----------------\\n\");\n    }\n\n    updateGrid() {\n        for(var i=0; i< this.grid.length-1; i++) {\n            for(var j=0; j< this.grid[i].length; j++) {\n                if ( this.grid[i][j] === \"water\") {\n                    if ( this.grid[i+1][j] === \"air\") {\n                         this.grid[i+1][j] = 4;\n                    } else if ( this.grid[i+1][j] === \"stone\") {\n                        if ( this.grid[i][j-1] === \"air\")  this.grid[i][j-1] = 4;\n                        if ( this.grid[i][j+1] === \"air\")  this.grid[i][j+1] = 4;\n                    }\n                    this.grid[i][j] = \"fixw\";\n                }\n            }\n        }\n        for(i=0; i< this.grid.length; i++) {\n            for(j=0; j< this.grid[i].length; j++) {\n                if ( this.grid[i][j] === 4)  this.grid[i][j] = \"water\";\n            }\n        }\n        \n    }\n    // updateBlock(x, y) {\n    //     if (this.grid[x][y] != \"water\")\n    // }\n\n//shouldnt this be grid[y][x]?\n    placeWater(x, y) {\n         this.grid[y][x] = \"water\";\n    }\n    // test code end\n\n    done() { //check sides, check split paths\n        for (let i = 0; i <  this.grid[0].length; i++) {\n            if ( this.grid[this.grid.length-1][i] === \"water\" ||  this.grid[this.grid.length-1][i] === \"fixw\") {\n                return true\n            }\n        }\n        return false\n    }\n\n    placeStone(x, y) {\n        this.grid[y][x] = \"stone\";\n    }\n    getIndex(x, y) {\n        return (\n          this.grid[y][x]\n        )\n      }\n}\n\nexport default GameGrid"]},"metadata":{},"sourceType":"module"}