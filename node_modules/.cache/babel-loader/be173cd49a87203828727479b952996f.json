{"ast":null,"code":"/**Types of blocks: \"air\"; \"stone\"; \"water\"; \"fixw\"; \"buck\"; \"obsi\"\n * 0 Air\n * 1 Stone\n * 2 Water\n * 3 Fixed water\n */\n\n/** Function takes in grid, coordinates and type of block to be placed\n * returns boolean representing success / failure\n */\nimport Block from './WaterLogic.js';\n\nclass GameGrid {\n  constructor(size) {\n    this.size = size;\n    this.grid = this.intializeGrid(size);\n    this.bucketGrid = null;\n    this.numToIcon = {\n      \"air\": \" \",\n      \"stone\": \"#\",\n      \"water\": \"o\",\n      \"fixw\": \"o\"\n    };\n    this.notupdated = false;\n  }\n\n  getSize() {\n    return this.size;\n  }\n\n  placeBlock(x, y, type) {\n    if (this.grid[y][x].blockType === \"air\") {\n      this.grid[y][x] = new Block(type);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /** Function takes in grid and replaces water blocks with air blocks\n   */\n\n\n  resetGrid() {\n    for (let x = 0; x < this.grid.length; x++) {\n      for (let y = 0; y < this.grid.length; y++) {\n        if (this.grid[y][x].blockType === \"water\" || this.grid[y][x].blockType === \"fixw\") {\n          this.grid[y][x] = new Block(\"air\");\n        }\n      }\n    }\n  }\n\n  intializeGrid() {\n    var grid = new Array(this.size);\n\n    for (var i = 0; i < this.size; i++) {\n      grid[i] = new Array(this.size);\n\n      for (var j = 0; j < this.size; j++) {\n        grid[i][j] = new Block(\"air\");\n      }\n    }\n\n    return grid;\n  }\n  /** Function initializes bucket grid, taking in as input size of grid and source and exit points (just x coordinate)\n   * for water. Places source of water and bucket on selected points, and obsidian everywhere else\n   */\n\n\n  initBucketGrid(size, sourceArray, exitArray) {\n    const HEIGHT = 2;\n    this.bucketGrid = new Array(HEIGHT);\n\n    for (var i = 0; i < HEIGHT; i++) {\n      this.bucketGrid[i] = new Array(size);\n\n      for (var j = 0; j < size; j++) {\n        this.bucketGrid[i][j] = new Block(\"air\");\n      }\n    }\n\n    for (let source in sourceArray) {\n      this.bucketGrid[0][source] = \"water\";\n    }\n\n    for (let exit in exitArray) {\n      this.bucketGrid[1][exit] = \"buck\";\n    }\n  }\n  /** Function returns boolean if block above bucket has water, representing win\n  */\n\n\n  checkForWin(grid, bucketGrid) {\n    let bucketLoc;\n    console.log(bucketGrid);\n\n    for (let i = 0; i < bucketGrid[1].length; i++) {\n      if (i === \"buck\") {\n        bucketLoc = i;\n      }\n    }\n\n    let previousBlock = grid[grid.length - 1][bucketLoc].blockType;\n\n    if (previousBlock === \"water\" || previousBlock == \"fixw\") {\n      return true;\n    }\n\n    return false;\n  }\n\n  printGrid() {\n    if (this.notupdated) throw \"not updated!\";\n    process.stdout.write(\"-----------------------------\\n\");\n\n    for (var i = 0; i < this.grid.length; i++) {\n      for (var j = 0; j < this.grid[i].length; j++) {\n        process.stdout.write(this.grid[i][j].print() + \"  \");\n      }\n\n      process.stdout.write(\"|\\n\");\n    }\n\n    process.stdout.write(\"-----------------------------\\n\");\n  }\n  /*\n  updateGrid() {\n      for(var i=0; i< this.grid.length-1; i++) {\n          for(var j=0; j< this.grid[i].length; j++) {\n              if ( this.grid[i][j].blockType === \"water\") {\n                  if ( this.grid[i+1][j].blockType === \"air\") {\n                       this.grid[i+1][j].blockType = 4;\n                  } else if ( this.grid[i+1][j].blockType === \"stone\") {\n                      if ( this.grid[i][j-1].blockType === \"air\")  this.grid[i][j-1] = 4;\n                      if ( this.grid[i][j+1].blockType === \"air\")  this.grid[i][j+1] = 4;\n                  }\n                  this.grid[i][j] = new Block(\"fixw\");\n              }\n          }\n      }\n      for(i=0; i< this.grid.length; i++) {\n          for(j=0; j< this.grid[i].length; j++) {\n              if ( this.grid[i][j].blockType === 4)  this.grid[i][j] = new Block(\"water\");\n          }\n      }\n      \n  }*/\n\n\n  updateGrid() {\n    this.updateAllNeighborBlock();\n    this.updateAllBlock();\n  }\n\n  updateAllNeighborBlock() {\n    for (let i = 0; i < this.grid.length; i++) {\n      for (let j = 0; j < this.grid[i].length; j++) {\n        this.updateNeighborBlock(i, j);\n      }\n    }\n  }\n\n  updateNeighborBlock(x, y) {\n    let nowBlock = this.grid[x][y];\n    if (nowBlock.blockType != \"water\") return;\n\n    if (nowBlock.downFlow) {\n      if (x + 1 >= this.grid.length) return; // last row\n\n      if (x + 2 >= this.grid.length || this.grid[x + 2][y].blockType == \"air\" || this.grid[x + 2][y].blockType == \"water\") {\n        this.grid[x + 1][y].initDownFlowWater();\n      } else if (this.grid[x + 2][y].blockType == \"stone\") {\n        if (this.grid[x + 1][y].blockType == \"air\") {\n          this.grid[x + 1][y].initWater(7, 7);\n        } else if (this.grid[x + 1][y].blockType == \"water\") {\n          this.grid[x + 1][y].heighten(7, 7); //hsidofisd\n        } else {\n          throw \"strange error 1\";\n        }\n      } else {\n        throw \"unknown block type\";\n      }\n    } else {\n      if (x == this.grid.length - 1 || this.grid[x + 1][y].blockType != \"stone\") {\n        this.grid[x + 1][y].initDownFlowWater();\n      } else {\n        if (y > 0) {\n          if (this.grid[x][y - 1].blockType == \"air\") {\n            this.grid[x][y - 1].initWater(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n          } else {\n            this.grid[x][y - 1].heighten(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n          }\n        }\n      }\n\n      if (y < this.grid[x].length - 1) {\n        if (this.grid[x][y + 1].blockType == \"air\") {\n          console.log(this.grid[x][y + 1]);\n          console.log(this.grid[x][y + 1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1));\n          this.grid[x][y + 1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n        } else {\n          this.grid[x][y + 1].heighten(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n        }\n      }\n    }\n  }\n\n  updateAllBlock() {\n    for (let i = 0; i < this.grid.length; i++) {\n      for (let j = 0; j < this.grid[i].length; j++) {\n        this.grid[i][j].update();\n      }\n    }\n\n    this.notupdated = false;\n  } //shouldnt this be grid[y][x]?\n\n\n  placeWater(x, y) {\n    this.notupdated = true;\n    if (x != 0) throw \"you can only place water at top row\";\n\n    if (this.grid[x + 1][y].blockType == \"stone\") {\n      this.grid[x][y].initWater(7, 7);\n    } else {\n      this.grid[x][y].initDownFlowWater();\n    }\n  } // test code end\n\n\n  done() {\n    //check sides, check split paths\n    for (let i = 0; i < this.grid[0].length; i++) {\n      if (this.grid[this.grid.length - 1][i].blockType === \"water\" || this.grid[this.grid.length - 1][i].blockType === \"fixw\") {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  placeBlock(x, y, material) {\n    this.grid[y][x] = new Block(material);\n  }\n\n  getIndex(x, y) {\n    return this.grid[y][x];\n  }\n\n} //test code 1 start\n\n\nlet game = new GameGrid(8);\ngame.placeBlock(4, 3, 'stone');\nexport default GameGrid;","map":{"version":3,"sources":["/Users/maxliu/HackGT8/src/GameLogic.js"],"names":["Block","GameGrid","constructor","size","grid","intializeGrid","bucketGrid","numToIcon","notupdated","getSize","placeBlock","x","y","type","blockType","resetGrid","length","Array","i","j","initBucketGrid","sourceArray","exitArray","HEIGHT","source","exit","checkForWin","bucketLoc","console","log","previousBlock","printGrid","process","stdout","write","print","updateGrid","updateAllNeighborBlock","updateAllBlock","updateNeighborBlock","nowBlock","downFlow","initDownFlowWater","initWater","heighten","waterLevel","update","placeWater","done","material","getIndex","game"],"mappings":"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","sourcesContent":["/**Types of blocks: \"air\"; \"stone\"; \"water\"; \"fixw\"; \"buck\"; \"obsi\"\n * 0 Air\n * 1 Stone\n * 2 Water\n * 3 Fixed water\n */\n\n/** Function takes in grid, coordinates and type of block to be placed\n * returns boolean representing success / failure\n */\nimport Block from './WaterLogic.js';\n\nclass GameGrid {\n\n    constructor(size) {\n        this.size = size;\n        this.grid = this.intializeGrid(size);\n        this.bucketGrid = null;\n        this.numToIcon = {\"air\":\" \", \"stone\":\"#\", \"water\":\"o\", \"fixw\":\"o\"};\n        this.notupdated = false;\n    }\n\n    getSize() {\n        return this.size;\n    }\n\n    placeBlock(x, y, type) {\n       if (this.grid[y][x].blockType === \"air\") {\n            this.grid[y][x] = new Block(type);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /** Function takes in grid and replaces water blocks with air blocks\n     */\n    resetGrid() {\n        for (let x = 0; x <  this.grid.length; x++) {\n            for (let y = 0; y <  this.grid.length; y++) {\n                if ( this.grid[y][x].blockType === \"water\" || this.grid[y][x].blockType === \"fixw\") {\n                     this.grid[y][x] = new Block(\"air\");\n                }\n            }\n        }\n    }\n\n    intializeGrid() {\n        var grid = new Array(this.size);\n        for (var i = 0; i < this.size; i++) {\n            grid[i] = new Array(this.size);\n            for(var j=0; j<this.size; j++) {\n                grid[i][j] = new Block(\"air\");\n            }\n        }\n        return grid;\n    }\n\n    /** Function initializes bucket grid, taking in as input size of grid and source and exit points (just x coordinate)\n     * for water. Places source of water and bucket on selected points, and obsidian everywhere else\n     */\n    initBucketGrid(size, sourceArray, exitArray) {\n        const HEIGHT = 2;\n        this.bucketGrid = new Array(HEIGHT);\n        for (var i = 0; i < HEIGHT; i++) {\n            this.bucketGrid[i] = new Array(size);\n            for(var j=0; j<size; j++) {\n                this.bucketGrid[i][j] = new Block(\"air\");\n            }\n        }\n        for (let source in sourceArray) {\n            this.bucketGrid[0][source] = \"water\";\n        }\n        for (let exit in exitArray) {\n            this.bucketGrid[1][exit] = \"buck\";\n        }\n    }\n    /** Function returns boolean if block above bucket has water, representing win\n    */\n    checkForWin(grid, bucketGrid) {\n        let bucketLoc\n        console.log(bucketGrid);\n        for (let i = 0; i < bucketGrid[1].length; i++) {\n            if (i === \"buck\") {\n                bucketLoc = i;\n            }\n        }\n        let previousBlock = grid[grid.length-1][bucketLoc].blockType;\n        if (previousBlock === \"water\" || previousBlock == \"fixw\") {\n            return true;\n        }\n        return false;\n    }\n\n\n    printGrid() {\n        if (this.notupdated) throw \"not updated!\";\n        process.stdout.write(\"-----------------------------\\n\");\n        for(var i=0; i< this.grid.length; i++) {\n            for(var j=0; j< this.grid[i].length; j++) {\n                process.stdout.write(this.grid[i][j].print() + \"  \");\n            }\n            process.stdout.write(\"|\\n\");\n        }\n        process.stdout.write(\"-----------------------------\\n\");\n    }\n    /*\n    updateGrid() {\n        for(var i=0; i< this.grid.length-1; i++) {\n            for(var j=0; j< this.grid[i].length; j++) {\n                if ( this.grid[i][j].blockType === \"water\") {\n                    if ( this.grid[i+1][j].blockType === \"air\") {\n                         this.grid[i+1][j].blockType = 4;\n                    } else if ( this.grid[i+1][j].blockType === \"stone\") {\n                        if ( this.grid[i][j-1].blockType === \"air\")  this.grid[i][j-1] = 4;\n                        if ( this.grid[i][j+1].blockType === \"air\")  this.grid[i][j+1] = 4;\n                    }\n                    this.grid[i][j] = new Block(\"fixw\");\n                }\n            }\n        }\n        for(i=0; i< this.grid.length; i++) {\n            for(j=0; j< this.grid[i].length; j++) {\n                if ( this.grid[i][j].blockType === 4)  this.grid[i][j] = new Block(\"water\");\n            }\n        }\n        \n    }*/\n\n    updateGrid() {\n        this.updateAllNeighborBlock();\n        this.updateAllBlock();\n    }\n    updateAllNeighborBlock() {\n        for(let i=0; i< this.grid.length; i++) {\n            for(let j=0; j< this.grid[i].length; j++) {\n                this.updateNeighborBlock(i, j);\n            }\n        }\n    }\n    updateNeighborBlock(x, y) {\n        let nowBlock = this.grid[x][y];\n        if (nowBlock.blockType != \"water\") return;\n        if (nowBlock.downFlow) {\n            if (x+1 >= this.grid.length) return; // last row\n            if (x+2 >= this.grid.length || this.grid[x+2][y].blockType == \"air\" || this.grid[x+2][y].blockType == \"water\") {\n                this.grid[x+1][y].initDownFlowWater();\n            } else if (this.grid[x+2][y].blockType == \"stone\") {\n                if (this.grid[x+1][y].blockType == \"air\") {\n                    this.grid[x+1][y].initWater(7, 7);\n                } else if (this.grid[x+1][y].blockType == \"water\") {\n                    this.grid[x+1][y].heighten(7, 7);\n                    //hsidofisd\n                } else {\n                    throw \"strange error 1\"\n                }\n            } else {\n                throw \"unknown block type\";\n            }\n        } else {\n            if (x == this.grid.length-1 || this.grid[x+1][y].blockType != \"stone\")  {\n                this.grid[x+1][y].initDownFlowWater();\n            } else {\n                if (y > 0) {\n                    if (this.grid[x][y-1].blockType == \"air\") {\n                        this.grid[x][y-1].initWater(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                    } else {\n                        this.grid[x][y-1].heighten(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                    }\n                }\n            }\n            if (y < this.grid[x].length - 1) {\n                if (this.grid[x][y+1].blockType == \"air\") {\n                    console.log(this.grid[x][y+1]);\n                    console.log(this.grid[x][y+1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1));\n                    this.grid[x][y+1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                } else {\n                    this.grid[x][y+1].heighten(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                }\n            }\n        }\n    }\n    updateAllBlock() {\n        for(let i=0; i< this.grid.length; i++) {\n            for(let j=0; j< this.grid[i].length; j++) {\n                this.grid[i][j].update();\n            }\n        }\n        this.notupdated = false;\n    }\n    \n\n//shouldnt this be grid[y][x]?\n    placeWater(x, y) {\n        this.notupdated = true;\n        if (x != 0) throw \"you can only place water at top row\";\n        if (this.grid[x+1][y].blockType == \"stone\") {\n            this.grid[x][y].initWater(7, 7);\n        } else {\n            this.grid[x][y].initDownFlowWater();\n        }\n    }\n    // test code end\n\n    done() { //check sides, check split paths\n        for (let i = 0; i <  this.grid[0].length; i++) {\n            if ( this.grid[this.grid.length-1][i].blockType === \"water\" ||  this.grid[this.grid.length-1][i].blockType === \"fixw\") {\n                return true\n            }\n        }\n        return false\n    }\n\n    placeBlock(x, y, material) {\n        this.grid[y][x] = new Block(material);\n    }\n    getIndex(x, y) {\n        return (\n          this.grid[y][x]\n        )\n    }\n}\n//test code 1 start\nlet game = new GameGrid(8);\ngame.placeBlock(4, 3, 'stone');\n\nexport default GameGrid;"]},"metadata":{},"sourceType":"module"}