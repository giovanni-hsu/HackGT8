{"version":3,"sources":["index.js","WaterLogic.js","GameLogic.js"],"names":["blockDict","stone","air","water","fixw","leftcornerwater","rightcornerwater","Square","props","state","material","grid","getIndex","x","y","blockType","block","this","waterLevel","dropShadow","className","onClick","placeBlock","setState","React","Component","Board","width","height","row","currentRow","col","push","columnIndex","rowIndex","map","renderSquare","renderedGrid","renderInitGrid","getSize","Game","waterInterval","GameGrid","size","console","log","initBucketGrid","waterStart","waterEnd","placeWater","updateAllBlock","setInterval","updateWater","game","updateGrid","done","clearInterval","startWater","ReactDOM","render","document","getElementById","Block","leftHeight","rightHeight","nextWaterLevel","updated","Math","max","intializeGrid","bucketGrid","numToIcon","notupdated","type","length","Array","i","j","sourceArray","exitArray","source","exit","bucketLoc","previousBlock","Error","process","stdout","write","print","updateAllNeighborBlock","updateNeighborBlock","nowBlock","initWater","heighten","update"],"mappings":"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","file":"static/js/main.fa4416c0.chunk.js","sourcesContent":["import { div } from 'prelude-ls';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport GameGrid from './GameLogic.js';\n\nconst blockDict = {\n  stone: {\n    'material' : 'stone',\n  },\n  air: {\n    'material' : 'air',\n  },\n  water: {\n    'material' : 'water',\n  },\n  fixw: {\n    'material' : 'fixw',\n  },\n  leftcornerwater: {\n    'material' : 'left-corner-water'\n  },\n  rightcornerwater: {\n    'material' : 'right-corner-water'\n  }\n\n};\n\nclass Square extends React.Component {\n\n  constructor(props) {\n    super(props);\n    //console.log(props);\n    // console.log('piece three', props.grid.getIndex(props.x, props.y), [props.x], [props.y]);\n    // console.log('important piece');\n    this.state = {\n      material: blockDict[props.grid.getIndex(props.x, props.y).blockType].material,\n    };\n    // console.log(this.props);\n  }\n\n  render() {\n    let block = this.props.grid.getIndex(this.props.x, this.props.y);\n    let material = block.blockType === 'water' ? \"water w\" + (block.waterLevel[0] + 1) + \"-\" + (block.waterLevel[1]+1) : blockDict[block.blockType].material;\n    let dropShadow = block.blockType === 'stone' ? \"drop-shadow\" : \"\";\n    return (\n      <button className={\"square \" + dropShadow} onClick={() => {\n          this.props.grid.placeBlock(this.props.x, this.props.y, 'stone'); \n          this.setState({material: this.state.material !== 'stone' ? 'stone' : 'air'})\n        }\n        }>\n        <div className=\"block-container\">\n          <div className={\"material \" + material}></div>\n          <div className={\"background-block\"}></div>\n        </div>\n      </button>\n    );\n  }\n}\n  \nclass Board extends React.Component {\n    renderSquare(material, x, y) {\n      //console.log('piece one', x, y, this.props.grid.getIndex(x,y));\n      return <Square x={x} y={y} grid={this.props.grid}/>;\n    }\n\n    renderInitGrid(width, height) {\n      const grid = [];\n      for (let row = 0; row < width; row++) {\n        const currentRow = [];\n        for (let col = 0; col < height; col++) {\n          currentRow.push(blockDict['air']);\n        }\n          grid.push(currentRow);\n      }\n      let columnIndex = -1;\n      let rowIndex = -1;\n      return grid.map((row) => {\n        columnIndex++;\n        rowIndex = -1;\n        return (\n          <div className=\"board-row\" key={columnIndex}>\n              {row.map((block) => {\n                rowIndex++;\n                //console.log('piece two', block.material, rowIndex, columnIndex, this.props.grid.grid[rowIndex][columnIndex]);\n                return (\n                  this.renderSquare(block.material, rowIndex, columnIndex)\n                );\n              })}\n          </div>\n        )\n      });\n\n    }\n\n    render() {\n      const status = 'Poggers';\n      const renderedGrid = this.renderInitGrid(this.props.grid.getSize(), this.props.grid.getSize());\n      // console.log(\"Rendered\");\n\n      return (\n        <div>\n          <div className=\"status\">{status}</div>\n\n          {renderedGrid}\n        </div>\n      );\n    }\n  }\n  \n  class Game extends React.Component {\n\n    constructor(props) {\n      super(props);\n      this.waterInterval = null;\n      this.state = {\n        grid: new GameGrid(props.size),\n      }\n      \n    }\n\n    startWater() {\n      console.log(this.state);\n      this.state.grid.initBucketGrid(this.props.size, this.props.waterStart, this.props.waterEnd);\n      this.state.grid.placeWater(this.props.waterStart[0], 0);\n      this.state.grid.updateAllBlock();\n      this.waterInterval = setInterval(() => {this.updateWater(this)}, 400);\n    }\n\n    updateWater(game) {\n      game.state.grid.updateGrid();\n      console.log(game.state.grid);\n      game.setState({grid: game.state.grid});\n      if (game.state.grid.done()) {\n        clearInterval(game.waterInterval);\n        //console.log(game.state.grid.checkForWin());//put in params\n      }\n    }\n\n    render() {\n      return (\n        <div className=\"game\">\n          <div className=\"game-board\">\n            <Board grid={this.state.grid}/>\n          </div>\n          <button onClick={() => {this.startWater()}}>Start water</button>\n        </div>\n      );\n    }\n  }\n  \n  // ========================================\n  \n  ReactDOM.render(\n    <Game size={8} waterStart={[0]} waterEnd={[5]}/>,\n    document.getElementById('root')\n  );\n  ","class Block {\n    constructor(blockType) {\n        this.blockType = blockType;\n    }\n    initWater(leftHeight, rightHeight) {\n        this.nextWaterLevel = [leftHeight, rightHeight];\n        this.waterLevel = [0, 0];\n        //this.downFlow = false;\n\n        this.updated = true\n    }\n    /*initDownFlowWater() {\n        this.nextWaterLevel = [7, 7];\n        this.waterLevel = [0, 0];\n        //this.downFlow = true;\n\n        this.updated = true\n    }*/\n    heighten(leftHeight, rightHeight) {\n        if (this.blockType !== \"water\") return;\n        this.nextWaterLevel[0] = Math.max(this.waterLevel[0], leftHeight, this.nextWaterLevel[0]);\n        this.nextWaterLevel[1] = Math.max(this.waterLevel[1], rightHeight, this.nextWaterLevel[1]);\n    }\n    update() {\n        if (!this.updated) return;\n        this.blockType = \"water\";\n        this.waterLevel[0] = this.nextWaterLevel[0];\n        this.waterLevel[1] = this.nextWaterLevel[1];\n        this.nextWaterLevel = [0, 0];\n        if (this.waterLevel[0] <= 0 && this.waterLevel[1] <= 0) {\n            this.blockType = \"air\";\n            this.waterLevel = [0, 0];\n        }\n        this.updated = false;\n    }\n    print() {\n        if (this.blockType === \"stone\") return \"##\";\n        if (this.blockType === \"air\") return \"  \";\n        if (this.blockType === \"water\") return this.waterLevel[0] + \"\" + this.waterLevel[1];\n    }\n}\nexport default Block;","/**Types of blocks: \"air\"; \"stone\"; \"water\"; \"fixw\"; \"buck\"; \"obsi\"\n * 0 Air\n * 1 Stone\n * 2 Water\n * 3 Fixed water\n */\n\n/** Function takes in grid, coordinates and type of block to be placed\n * returns boolean representing success / failure\n */\nimport Block from './WaterLogic.js';\n\nclass GameGrid {\n\n    constructor(size) {\n        this.size = size;\n        this.grid = this.intializeGrid(size);\n        this.bucketGrid = null;\n        this.numToIcon = {\"air\":\" \", \"stone\":\"#\", \"water\":\"o\", \"fixw\":\"o\"};\n        this.notupdated = false;\n    }\n\n    getSize() {\n        return this.size;\n    }\n\n    placeBlock(x, y, type) {\n       if (this.grid[y][x].blockType === \"air\") {\n            this.grid[y][x] = new Block(type);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /** Function takes in grid and replaces water blocks with air blocks\n     */\n    resetGrid() {\n        for (let x = 0; x <  this.grid.length; x++) {\n            for (let y = 0; y <  this.grid.length; y++) {\n                if ( this.grid[y][x].blockType === \"water\" || this.grid[y][x].blockType === \"fixw\") {\n                     this.grid[y][x] = new Block(\"air\");\n                }\n            }\n        }\n    }\n\n    intializeGrid() {\n        var grid = new Array(this.size);\n        for (var i = 0; i < this.size; i++) {\n            grid[i] = new Array(this.size);\n            for(var j=0; j<this.size; j++) {\n                grid[i][j] = new Block(\"air\");\n            }\n        }\n        return grid;\n    }\n\n    /** Function initializes bucket grid, taking in as input size of grid and source and exit points (just x coordinate)\n     * for water. Places source of water and bucket on selected points, and obsidian everywhere else\n     */\n    initBucketGrid(size, sourceArray, exitArray) {\n        const HEIGHT = 2;\n        this.bucketGrid = new Array(HEIGHT);\n        for (var i = 0; i < HEIGHT; i++) {\n            this.bucketGrid[i] = new Array(size);\n            for(var j=0; j<size; j++) {\n                this.bucketGrid[i][j] = new Block(\"air\");\n            }\n        }\n        for (let source in sourceArray) {\n            this.bucketGrid[0][source] = \"water\";\n        }\n        for (let exit in exitArray) {\n            this.bucketGrid[1][exit] = \"buck\";\n        }\n    }\n    /** Function returns boolean if block above bucket has water, representing win\n    */\n    checkForWin(grid, bucketGrid) {\n        let bucketLoc\n        console.log(bucketGrid);\n        for (let i = 0; i < bucketGrid[1].length; i++) {\n            if (i === \"buck\") {\n                bucketLoc = i;\n            }\n        }\n        let previousBlock = grid[grid.length-1][bucketLoc].blockType;\n        if (previousBlock === \"water\" || previousBlock === \"fixw\") {\n            return true;\n        }\n        return false;\n    }\n\n\n    printGrid() {\n        if (this.notupdated) throw new Error(\"not updated!\");\n        process.stdout.write(\"-----------------------------\\n\");\n        for(var i=0; i< this.grid.length; i++) {\n            for(var j=0; j< this.grid[i].length; j++) {\n                process.stdout.write(this.grid[i][j].print() + \"  \");\n            }\n            process.stdout.write(\"|\\n\");\n        }\n        process.stdout.write(\"-----------------------------\\n\");\n    }\n    /*\n    updateGrid() {\n        for(var i=0; i< this.grid.length-1; i++) {\n            for(var j=0; j< this.grid[i].length; j++) {\n                if ( this.grid[i][j].blockType === \"water\") {\n                    if ( this.grid[i+1][j].blockType === \"air\") {\n                         this.grid[i+1][j].blockType = 4;\n                    } else if ( this.grid[i+1][j].blockType === \"stone\") {\n                        if ( this.grid[i][j-1].blockType === \"air\")  this.grid[i][j-1] = 4;\n                        if ( this.grid[i][j+1].blockType === \"air\")  this.grid[i][j+1] = 4;\n                    }\n                    this.grid[i][j] = new Block(\"fixw\");\n                }\n            }\n        }\n        for(i=0; i< this.grid.length; i++) {\n            for(j=0; j< this.grid[i].length; j++) {\n                if ( this.grid[i][j].blockType === 4)  this.grid[i][j] = new Block(\"water\");\n            }\n        }\n        \n    }*/\n\n    updateGrid() {\n        this.updateAllNeighborBlock();\n        this.updateAllBlock();\n    }\n    updateAllNeighborBlock() {\n        for(let i=0; i< this.grid.length; i++) {\n            for(let j=0; j< this.grid[i].length; j++) {\n                this.updateNeighborBlock(i, j);\n            }\n        }\n    }\n    /*\n    updateNeighborBlock(x, y) {\n        let nowBlock = this.grid[x][y];\n        if (nowBlock.blockType !== \"water\") return;\n        if (nowBlock.downFlow) {\n            if (x+1 >= this.grid.length) return; // last row\n            if (x+2 >= this.grid.length || this.grid[x+2][y].blockType === \"air\" || this.grid[x+2][y].blockType === \"water\") {\n                this.grid[x+1][y].initDownFlowWater();\n            } else if (this.grid[x+2][y].blockType === \"stone\") {\n                if (this.grid[x+1][y].blockType === \"air\") {\n                    this.grid[x+1][y].initWater(7, 7);\n                } else if (this.grid[x+1][y].blockType === \"water\") {\n                    this.grid[x+1][y].heighten(7, 7);\n                    //hsidofisd\n                } else {\n                    throw new Error(\"strange error 1\");\n                }\n            } else {\n                throw new Error(\"unknown block type\");\n            }\n        } else {\n            if (x === this.grid.length-1 || this.grid[x+1][y].blockType !== \"stone\")  {\n                this.grid[x+1][y].initDownFlowWater();\n            } else {\n                if (y > 0) {\n                    if (this.grid[x][y-1].blockType === \"air\") {\n                        this.grid[x][y-1].initWater(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                    } else {\n                        this.grid[x][y-1].heighten(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                    }\n                }\n                if (y < this.grid[x].length - 1) {\n                    if (this.grid[x][y+1].blockType === \"air\") {\n                        console.log(this.grid[x][y+1]);\n                        console.log(this.grid[x][y+1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1));\n                        this.grid[x][y+1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                    } else {\n                        this.grid[x][y+1].heighten(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                    }\n                }\n            }\n            \n        }\n    }*/\n    updateNeighborBlock(x, y) {\n        let nowBlock = this.grid[x][y];\n        if (x<0 || x>= this.grid.length || y<0 || y>=this.grid[0]) throw new Error(\"x, y not in range\");\n        if (nowBlock.blockType !== \"water\") return;\n\n\n        if (x === this.grid.length-1) {\n            return;\n        } else if (this.grid[x+1][y].blockType !== \"stone\") {\n            if (this.grid[x+1][y].blockType === \"air\") {\n                this.grid[x+1][y].initWater(7, 7);\n            } else if (this.grid[x+1][y].blockType === \"water\") {\n                this.grid[x+1][y].heighten(7, 7);\n                //hsidofisd\n            } else {\n                throw new Error(\"strange error 1\");\n            }\n        } else {\n            if (y > 0) {\n                if (this.grid[x][y-1].blockType === \"air\") {\n                    this.grid[x][y-1].initWater(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                } else {\n                    this.grid[x][y-1].heighten(nowBlock.waterLevel[0] - 1, nowBlock.waterLevel[0]);\n                }\n            }\n            if (y < this.grid[x].length - 1) {\n                if (this.grid[x][y+1].blockType === \"air\") {\n                    this.grid[x][y+1].initWater(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                } else {\n                    this.grid[x][y+1].heighten(nowBlock.waterLevel[1], nowBlock.waterLevel[1] - 1);\n                }\n            }\n        }\n    }\n    updateAllBlock() {\n        for(let i=0; i< this.grid.length; i++) {\n            for(let j=0; j< this.grid[i].length; j++) {\n                this.grid[i][j].update();\n            }\n        }\n        this.notupdated = false;\n    }\n    \n\n//shouldnt this be grid[y][x]?\n    placeWater(x, y) {\n        this.notupdated = true;\n        if (x !== 0) throw new Error(\"you can only place water at top row\");\n        this.grid[x][y].initWater(7, 7);\n        /*if (this.grid[x+1][y].blockType === \"stone\") {\n            this.grid[x][y].initWater(7, 7);\n        } else {\n            this.grid[x][y].initDownFlowWater();\n        }*/\n    }\n    // test code end\n\n    done() { //check sides, check split paths\n        for(var x=0; x< this.grid.length; x++) {\n            for(var y=0; y< this.grid[x].length; y++) {\n                if (this.grid[x][y].blockType !== \"water\") continue;\n                if (x === this.grid.length-1) continue;\n                if (this.grid[x+1][y].blockType === \"air\") return false;\n                else if (this.grid[x+1][y].blockType === \"stone\") {\n                    if (y > 0) {\n                        if (this.grid[x][y-1].blockType === \"air\") return false\n                    }\n                    if (y < this.grid[x].length - 1) {\n                        if (this.grid[x][y+1].blockType === \"air\") return false\n                    }\n                }\n            }\n        }\n        return true\n    }\n\n    /*placeBlock(x, y, material) {\n        this.grid[y][x] = new Block(material);\n    }*/\n    getIndex(x, y) {\n        return (\n          this.grid[y][x]\n        )\n    }\n}\n//test code 1 start\nlet game = new GameGrid(8);\ngame.placeBlock(4, 3, 'stone');\n\nexport default GameGrid;"],"sourceRoot":""}